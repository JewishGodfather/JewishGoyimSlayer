<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shooting Zombie Humans</title>
  <style>
    canvas {
      background-image: url('background.jpg');
      background-size: cover;
      display: block;
      margin: 0 auto;
    }
    body {
      margin: 0;
      padding: 0;
    }
    .kill-counter {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 30px;
      font-family: Arial, sans-serif;
      z-index: 10; /* Ensure it stays on top of the canvas */
    }
  </style>
</head>
<body>
  <!-- Kill counter added here -->
  <div class="kill-counter">Points: 0</div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const killCounterElement = document.querySelector(".kill-counter");

let zombies = [];
let particles = [];
let points = 0; // Changed from kills to points

class Zombie {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 50;
    this.speed = 0.5 + Math.random() * 0.5;
    this.direction = Math.random() * Math.PI * 2;
    this.health = 100;
  }

  move() {
    this.x += Math.cos(this.direction) * this.speed;
    this.y += Math.sin(this.direction) * this.speed;

    // Bounce off walls
    if (this.x < 50 || this.x > canvas.width - 50) this.direction = Math.PI - this.direction;
    if (this.y < 50 || this.y > canvas.height - 150) this.direction = -this.direction;
  }

  draw() {
    const headRadius = this.size / 5; // Slightly smaller head
    const bodyLength = this.size * 1.5; // Longer torso for human-like proportions
    const armLength = this.size / 1.5;
    const legLength = this.size / 1.2;

    const zombieColor = "#5C4033"; // Dark Brown

    // Head (more human-like, slightly oval)
    ctx.fillStyle = zombieColor;
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, headRadius, headRadius * 1.2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (more realistic human positioning)
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(this.x - 8, this.y - 8, 5, 0, Math.PI * 2);
    ctx.arc(this.x + 8, this.y - 8, 5, 0, Math.PI * 2);
    ctx.fill();

    // Pupils
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(this.x - 8, this.y - 8, 2, 0, Math.PI * 2);
    ctx.arc(this.x + 8, this.y - 8, 2, 0, Math.PI * 2);
    ctx.fill();

    // Nose (subtle for a cartoonish effect)
    ctx.beginPath();
    ctx.arc(this.x, this.y - 2, 2, 0, Math.PI * 2);
    ctx.fill();

    // Mouth (simple, subtle line for human look)
    ctx.beginPath();
    ctx.arc(this.x, this.y + 6, 5, 0, Math.PI);
    ctx.stroke();

    ctx.strokeStyle = zombieColor;
    ctx.lineWidth = 2;

    // Body (more human body shape)
    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2);
    ctx.lineTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.stroke();

    // Arms (more realistic positioning)
    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + 10);
    ctx.lineTo(this.x - armLength, this.y + headRadius * 1.2 + bodyLength / 2);
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + 10);
    ctx.lineTo(this.x + armLength, this.y + headRadius * 1.2 + bodyLength / 2);
    ctx.stroke();

    // Legs (slightly more bent for natural posture)
    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.lineTo(this.x - legLength / 2, this.y + headRadius * 1.2 + bodyLength + legLength);
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.lineTo(this.x + legLength / 2, this.y + headRadius * 1.2 + bodyLength + legLength);
    ctx.stroke();

    // Adding watermelon and KFC bucket as fun accessories
    // Watermelon (held in zombie hand)
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(this.x - armLength - 10, this.y + headRadius * 1.2 + bodyLength / 2, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "red"; // Watermelon inside
    ctx.beginPath();
    ctx.arc(this.x - armLength - 10, this.y + headRadius * 1.2 + bodyLength / 2, 10, 0, Math.PI * 2);
    ctx.fill();

    // Add small black seeds in the watermelon
    ctx.fillStyle = "black";
    // Draw seeds in a circular arrangement inside the watermelon
    ctx.beginPath();
    ctx.arc(this.x - armLength - 13, this.y + headRadius * 1.2 + bodyLength / 2 - 4, 2, 0, Math.PI * 2); // Seed 1
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.x - armLength - 8, this.y + headRadius * 1.2 + bodyLength / 2 + 2, 2, 0, Math.PI * 2); // Seed 2
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.x - armLength - 12, this.y + headRadius * 1.2 + bodyLength / 2 + 6, 2, 0, Math.PI * 2); // Seed 3
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.x - armLength - 5, this.y + headRadius * 1.2 + bodyLength / 2 + 4, 2, 0, Math.PI * 2); // Seed 4
    ctx.fill();

    // KFC Bucket (held in zombie hand)
    ctx.fillStyle = "white";
    ctx.fillRect(this.x + armLength - 10, this.y + headRadius * 1.2 + bodyLength / 2, 20, 30);
    ctx.fillStyle = "red";
    ctx.fillRect(this.x + armLength - 10, this.y + headRadius * 1.2 + bodyLength / 2 + 5, 20, 10); // Red band on the bucket
    ctx.fillStyle = "black";
    ctx.fillText("KFC", this.x + armLength - 5, this.y + headRadius * 1.2 + bodyLength / 2 + 20);
  }

  isHit(x, y) {
    return Math.hypot(this.x - x, this.y - y) < this.size;
  }
}

class BloodParticle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 4 - 2;  // Random horizontal speed
    this.vy = Math.random() * 4 - 2;  // Random vertical speed
    this.life = 20; // Blood particle life duration
    this.size = Math.random() * 5 + 2; // Random size for more natural look
    this.color = "red"; // Blood color
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.life--; // Decrease life over time
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function spawnZombie() {
  const marginX = 100;
  const marginY = 150;
  const x = marginX + Math.random() * (canvas.width - 2 * marginX);
  const y = marginY + Math.random() * (canvas.height - 2 * marginY);
  zombies.push(new Zombie(x, y));
}

function updateGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  zombies.forEach(z => {
    z.move();
    z.draw();
  });

  particles.forEach((p, i) => {
    p.update();
    p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  });

  // Update the point counter display
  killCounterElement.textContent = `Points: ${points}`;

  requestAnimationFrame(updateGame);
}

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  zombies.forEach((z, i) => {
    if (z.isHit(mx, my)) {
      zombies.splice(i, 1);
      points++; // Increment the points counter
      // Create blood splatter effect
      for (let j = 0; j < 30; j++) {
        particles.push(new BloodParticle(z.x, z.y));
      }
      // Respawn a new zombie after a short delay
      setTimeout(() => {
        spawnZombie();
      }, 1000); // 1 second delay before respawn
    }
  });
});

// Initial spawn
for (let i = 0; i < 5; i++) spawnZombie();
updateGame();
</script>
</body>
</html>
