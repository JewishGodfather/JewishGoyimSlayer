<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shooting Zombie Humans</title>
  <style>
    canvas {
      background-image: url('background.jpg');
      background-size: cover;
      display: block;
      margin: 0 auto;
    }
    body {
      margin: 0;
      padding: 0;
    }
    .kill-counter {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 30px;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
    .leaderboard {
      position: absolute;
      top: 50px;
      right: 10px;
      color: white;
      font-size: 20px;
      font-family: Arial, sans-serif;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
    }
    .leaderboard h3 {
      margin: 0;
      padding-bottom: 10px;
    }
    .leaderboard ul {
      list-style-type: none;
      padding: 0;
    }
    .leaderboard li {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div class="kill-counter">Kills: 0</div>
  <div class="leaderboard">
    <h3>Leaderboard</h3>
    <ul id="leaderboardList"></ul>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const killCounterElement = document.querySelector(".kill-counter");
const leaderboardList = document.getElementById("leaderboardList");

let zombies = [];
let particles = [];
let kills = 0; // Track the number of kills
let score = 0; // Track the score

// Zombie class (remains the same)
class Zombie {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 50;
    this.speed = 0.5 + Math.random() * 0.5;
    this.direction = Math.random() * Math.PI * 2;
    this.health = 100;
  }

  move() {
    this.x += Math.cos(this.direction) * this.speed;
    this.y += Math.sin(this.direction) * this.speed;

    if (this.x < 50 || this.x > canvas.width - 50) this.direction = Math.PI - this.direction;
    if (this.y < 50 || this.y > canvas.height - 150) this.direction = -this.direction;
  }

  draw() {
    const headRadius = this.size / 5;
    const bodyLength = this.size * 1.5;
    const armLength = this.size / 1.5;
    const legLength = this.size / 1.2;

    ctx.fillStyle = "#5C4033";
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, headRadius, headRadius * 1.2, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(this.x - 8, this.y - 8, 5, 0, Math.PI * 2);
    ctx.arc(this.x + 8, this.y - 8, 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(this.x - 8, this.y - 8, 2, 0, Math.PI * 2);
    ctx.arc(this.x + 8, this.y - 8, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#5C4033";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2);
    ctx.lineTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + 10);
    ctx.lineTo(this.x - armLength, this.y + headRadius * 1.2 + bodyLength / 2);
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + 10);
    ctx.lineTo(this.x + armLength, this.y + headRadius * 1.2 + bodyLength / 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.lineTo(this.x - legLength / 2, this.y + headRadius * 1.2 + bodyLength + legLength);
    ctx.moveTo(this.x, this.y + headRadius * 1.2 + bodyLength);
    ctx.lineTo(this.x + legLength / 2, this.y + headRadius * 1.2 + bodyLength + legLength);
    ctx.stroke();
  }

  isHit(x, y) {
    return Math.hypot(this.x - x, this.y - y) < this.size;
  }
}

// Blood Particle class (remains the same)
class BloodParticle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 4 - 2;
    this.vy = Math.random() * 4 - 2;
    this.life = 20;
    this.size = Math.random() * 5 + 2;
    this.color = "red";
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.life--;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function spawnZombie() {
  const marginX = 100;
  const marginY = 150;
  const x = marginX + Math.random() * (canvas.width - 2 * marginX);
  const y = marginY + Math.random() * (canvas.height - 2 * marginY);
  zombies.push(new Zombie(x, y));
}

function updateGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  zombies.forEach(z => {
    z.move();
    z.draw();
  });

  particles.forEach((p, i) => {
    p.update();
    p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  });

  // Update the kill counter display
  killCounterElement.textContent = `Kills: ${kills}`;
  updateLeaderboard();

  requestAnimationFrame(updateGame);
}

// Update leaderboard
function updateLeaderboard() {
  let leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
  leaderboard.push(score);
  leaderboard = leaderboard.sort((a, b) => b - a).slice(0, 5); // Sort in descending order and keep top 5 scores
  localStorage.setItem("leaderboard", JSON.stringify(leaderboard));

  leaderboardList.innerHTML = leaderboard.map(score => `<li>${score}</li>`).join("");
}

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  zombies.forEach((z, i) => {
    if (z.isHit(mx, my)) {
      zombies.splice(i, 1);
      kills++;
      score += 10; // Add points for killing a zombie
      for (let j = 0; j < 30; j++) {
        particles.push(new BloodParticle(z.x, z.y));
      }
      setTimeout(() => {
        spawnZombie();
      }, 1000);
    }
  });
});

window.addEventListener("beforeunload", () => {
  let leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
  leaderboard.push(score);
  leaderboard = leaderboard.sort((a, b) => b - a).slice(0, 5);
  localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
});

// Initial spawn
for (let i = 0; i < 5; i++) spawnZombie();
updateGame();
</script>
</body>
</html>
